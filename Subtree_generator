import itertools
import numpy as np

iter = [ [1], [0,1], [0,1], [0,1], [0,1] ] #number of possible children, first entry can't be zero

fg = len(iter[0]) #number of first gen children
sg = len(iter[1])-1 #number of second gen children
tg = len(iter[2])-1 #number of third gen children
fog = len(iter[3])-1 #number of fourth gen children 
fig = len(iter[4])-1 #number of fifth gen children


l = len(iter) #number of parents in tree ~ non leaves

for t in itertools.product(*iter): #all possible combos of iter
    
    fm = t[0] #first entry of each subtree vector
    sm = t[1] #second entry of each subtree vector
    tm = t[2] #third entry of each subtree vector
    fom = t[3] #fourth entry of each subtree vector
    fim = t[4] #fifth entry of each subtree vector
    
    fn = np.count_nonzero(t[0:fg]) #number of nonzero first gen children
    print(fn)
    
    sn = np.count_nonzero(t[fg:sg+fg]) #number of nonzero second gen children
    print(sn)
    
    tn = np.count_nonzero(t[sg+fg:tg+sg+fg]) #number of nonzero third gen children
    print(tn)
    
    fon = np.count_nonzero(t[tg+sg+fg:fog+tg+sg+fg]) #number of nonzero fourth gen children
    print(fon)
    
    fin = np.count_nonzero(t[fog+tg+sg+fg:len(t)]) #number of nonzero fifth gen children
    print(fin)
    
    print([s for s in t if sn<=fm and tn<=sm and fon<=tm and fin<=fom]) #printing subtree vectors that have enough parents for 1-5 gen children
